<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>^_^</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="^_^">
<meta property="og:url" content="http://tangzhenh.com/index.html">
<meta property="og:site_name" content="^_^">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="^_^">
  
    <link rel="alternate" href="/atom.xml" title="^_^" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">^_^</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://tangzhenh.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-react-router-v4-x" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/02/react-router-v4-x/" class="article-date">
  <time datetime="2017-06-02T08:20:18.000Z" itemprop="datePublished">2017-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/02/react-router-v4-x/">react-router_v4.x 使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 <code>web</code> 应用开发中，路由系统是不可或缺的一部分。当浏览器的 <code>URL</code> 发生变化时，意味着用户产生了新的请求, 路由系统会根据请求资源的路径, 将这些请求分发给与之对应的服务进行处理.</p>
<h3 id="传统-Web-开发方式"><a href="#传统-Web-开发方式" class="headerlink" title="传统 Web 开发方式"></a>传统 Web 开发方式</h3><p>在传统的网页应用架构中，用户通过浏览器, 将请求发送给服务端.<br>在服务端有一个叫控制器的东西, 负责统一处理前端的请求, 其中就包含了路由的分发. 控制器中维护了一套路由列表, 里面配置的是, 请求路径与服务方法的映射关系. 当控制器接收到用户请求之后, 根据请求的路径, 调用与之对应的服务方法. 服务再根据某些业务规则,完成数据的处理, 最后生成新的页面返回给浏览器. </p>
<p>比如, 当用户请求 <code>/users/login</code> 时, 控制器在路由列表中匹配到这个路径, 同时调用 <code>loginService</code> 方法进行业务处理, 处理完成之后, 将处理完成之后的数据加上页面返回给浏览器端. 浏览器直接拿到页面后完成渲染. </p>
<p>在这样的架构中, 浏览器实际上就只是一个展示数据的地方, 路由配置, 服务的调用, 以及页面跳转的流程都是由服务端来完成. </p>
<p>以上是传统的网页应用方式, 可以看到, 在这种方式下, 开发的重心都偏向于服务端, 浏览器只是用于数据的展示. 而且, 当页面数据需要更新时, 会刷新整个页面, 这会导致资源的浪费.</p>
<p>下面我们再来看看单页应用的开发方式.</p>
<h3 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h3><p>相对于传统的网页应用, 在单页的方式下, 控制器被前置到浏览器端, 也就是说, 当浏览器的访问地址发生变化时, 请求不在是发送到服务端, 而是在浏览器端直接响应. 同时, 视图的更新也不在是从一个页面跳转到另一个页面. 取而代之的是, 使用一个组件替换另一个组件. 原先的服务端则逐渐简化成一个单纯提供数据的服务, 供浏览器调用. </p>
<h3 id="如何创建一个前端路由"><a href="#如何创建一个前端路由" class="headerlink" title="如何创建一个前端路由"></a>如何创建一个前端路由</h3><p>前端路由在功能上实际和服务端路由是一样的. 通过路由列表来维护用户访问路径和组件之间的关系. 我们可以利用 <code>url</code> 中的 <code>hash</code> 属性和 <code>HTML5</code> 中的 <code>history API</code> 来创建前端路由. </p>
<p>下面我们首先来看一下 <code>hash</code> 的特性</p>
<h4 id="1-hash-属性"><a href="#1-hash-属性" class="headerlink" title="1. hash 属性"></a>1. hash 属性</h4><p><code>url</code> 中的 <code>hash</code> 属性表示网页中的一个位置. 其 <code>#</code> 后面的字符, 就是 <code>hash</code> 属性的值. 也就是我们经常所说的锚点. 比如下面这个访问地址: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.example.com/index.html/#login</div></pre></td></tr></table></figure>
<p>这个 <code>url</code> 就表示需要访问 <code>index.html</code> 页面中的 <code>login</code> 位置. 浏览器在加载 <code>index.html</code> 页面完成之后, 会自动将页面中 <code>login</code> 位置的内容显示出来. </p>
<p>hash 属性除了可以用来实现页内导航以外, 还有一个重要的特性, 就是当 hash 值发生改变时, 不会引起页面的刷新. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.example.com/index.html/#reg</div></pre></td></tr></table></figure>
<p>比如, 用户将 <code>login</code> 改成 <code>reg</code>, 浏览器会定位到新的位置, 而不会重新加载网页. 并且每一次改变 <code>hash</code> 值, 都会在浏览器的访问历史中增加一个记录, 使用”后退”按钮, 就可以回到上一个位置.</p>
<p>下面, 我们根据 <code>hash</code> 属性, 来创建一个基础的路由系统.</p>
<p>我们需要在 <code>index.html</code> 页面中完成登录界面, 注册界面和信息界面的相互切换. </p>
<p>首先看一下<code>url</code>和视图之间的映射关系: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">http://www.example.com/index.html/#login 访问登录界面</div><div class="line">http://www.example.com/index.html/#reg 访问注册界面</div><div class="line">http://www.example.com/index.html/#info 访问信息界面</div></pre></td></tr></table></figure>
<ul>
<li><code>#login</code>用来标志访问登录界面, <code>#reg</code>表示注册界面, <code>#info</code>则是信息界面</li>
<li>首先在<code>index.html</code>页面中, 添加一个<code>div</code>, 作为视图容器. 当用户访问不同的<code>url</code>时, 容器就显示对应的视图. </li>
<li>然后创建路由处理函数. 通过 <code>location.hash</code> 获取到当前的 <code>hash</code> 值进行路径匹配, 匹配成功之后, 返回对应的视图, 否则返回登录界面. 这里我们使用 <code>switch</code> 来进行匹配</li>
<li>最后, 添加事件监听. 在<code>HTML 5</code>中, 新增了一个 <code>onhashchange</code> 的事件, 当 <code>hash</code> 值发生改变时, 就会触发这个事件. 这里, 我们添加这个事件, 当事件触发时, 调用路由处理函数.</li>
<li>打开浏览器, 刷新页面, 修改<code>hash</code>值, 这时, 页面会随着<code>url</code>的改变切换到与之对应的视图.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function router() &#123;</div><div class="line">	const hash = location.hash</div><div class="line">	switch(hash) &#123;</div><div class="line">		case &quot;#login&quot;:</div><div class="line">			app.innerHTML = `&lt;h1&gt;登录界面&lt;/h1&gt;`</div><div class="line">			return;</div><div class="line">		case &quot;#reg&quot;:</div><div class="line">			app.innerHTML = `&lt;h1&gt;注册界面&lt;/h1&gt;`</div><div class="line">			return;</div><div class="line">		case &quot;#info&quot;:</div><div class="line">			app.innerHTML = `&lt;h1&gt;信息界面&lt;/h1&gt;`</div><div class="line">			return;</div><div class="line">		default:</div><div class="line">			app.innerHTML = `&lt;h1&gt;信息界面&lt;/h1&gt;`</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">router()</div><div class="line"></div><div class="line">window.addEventListener(&quot;hashchange&quot;, function() &#123;</div><div class="line">	router()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>以上就是通过 <code>hash</code> 属性, 创建的一个最简单的路由系统.</p>
<p>除了 <code>hash</code> 属性之外, 我们还可以通过<code>HTML5</code>中的<code>history API</code>来创建路由系统.</p>
<h4 id="2-HTML-5-history"><a href="#2-HTML-5-history" class="headerlink" title="2. HTML 5 history"></a>2. HTML 5 history</h4><p>在<code>HTML 5</code>中, 我们可以使用<code>pushState</code>方法来实现路由. </p>
<p> <code>pushState</code>方法用来修改<code>url</code>, 并将最新的 <code>url</code> 添加到历史记录. 该方法接收3个参数, 第一个参数是状态对象<code>(state object)</code>, 用来描述当前历史记录. 第二个参数为标题<code>title</code>. 第三个<code>url</code>, 这个参数提供了新历史记录的地址. </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">history.pushState(&#123;&#125;, null, &quot;/login&quot;)</div></pre></td></tr></table></figure>
<p>例如, 当用户访问<code>index.html</code>页面时, 调用<code>pushState</code>方法,<br>浏览器做了2件事情:</p>
<ul>
<li><p>第一, 将<code>url</code>路径修改成用户指定的地址,也就是<code>/login</code> </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:3001/index.html -&gt; http://localhost:3001/login</div></pre></td></tr></table></figure>
</li>
<li><p>第二, 将这个地址添加到历史记录.</p>
</li>
</ul>
<p>这里需要注意一下的是, 当浏览器调用<code>pushState</code>方法操作<code>url</code>的时候, 浏览器只会修改<code>url</code>路径, 不会根据<code>url</code>请求服务端, 这时我们就可以进行视图的切换. 但是如果用户直接通过地址栏输入的方式来访问该地址的时候, 这时浏览器会根据访问的路径去请求服务端获取资源. 因此, 使用这种方式来实现路由, 还需要后台服务器与之配合完成.</p>
<p>以上两种就是常见的路由实现方式, 很多前端路由就是基于以上的方式在实现, 其中就包括<code>react-router</code>. 下面我们来看看, 在单页开发中, 如何使用<code>react-router</code>提供的路由功能.</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先在项目中安装 <code>react-router</code> 依赖, <code>V4.X</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 4.0 版本以上</div><div class="line">npm install react-router-dom --save</div></pre></td></tr></table></figure>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><h4 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h4><p>接下来, 我们要来实现一个包含登录, 注册以及信息管理功能的应用, 整个应用的结构如下: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">index.html  // 主页面</div><div class="line">src</div><div class="line"> │  app.js  // 应用入口程序</div><div class="line"> └─ components </div><div class="line">     │  login.js    // 登录组件    </div><div class="line">     │  reg.js      // 注册组件</div><div class="line">     └─ info</div><div class="line">             emp.js     // 员工组件</div><div class="line">             student.js // 学生组件</div><div class="line">             system.js  // 系统组件</div><div class="line">             teacher.js // 教师组件</div></pre></td></tr></table></figure>
<ul>
<li><code>index.html</code> 是应用的主页面, 因为采用单页开发的方式, 因此整个应用的视图都在这个页面进行切换展示. </li>
<li><code>app.js</code> 是整个应用的入口程序, 用来整合和配置该应用的其他组件. </li>
<li><code>components</code> 目录用来存放整个应用的组件.</li>
<li>其中 <code>login.js</code> 为登录组件</li>
<li><code>reg.js</code> 为注册组件</li>
<li><code>info</code> 目录, 存放信息管理模块的相关组件, 其中 <code>emp.js</code> 是员工组件, <code>student.js</code> 学生组件, <code>system.js</code> 系统组件, <code>teacher.js</code> 教师组件.  </li>
</ul>
<p>整个应用的结构, 以及包含的主要模块大致如上, 首先在项目中创建这些组件. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">// student.js</div><div class="line">import React from &quot;react&quot;;</div><div class="line">export default class Student extends React.Component &#123;</div><div class="line">	constructor(props) &#123;</div><div class="line">		super(props);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	render() &#123;</div><div class="line">		return (</div><div class="line">			&lt;div&gt;</div><div class="line">				&lt;h1&gt;学生管理&lt;/h1&gt;</div><div class="line">			&lt;/div&gt;</div><div class="line">		);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// system.js</div><div class="line">import React from &quot;react&quot;;</div><div class="line">export default class System extends React.Component &#123;</div><div class="line">	constructor(props) &#123;</div><div class="line">		super(props);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	render() &#123;</div><div class="line">		return (</div><div class="line">			&lt;div&gt;</div><div class="line">				&lt;h1&gt;系统管理&lt;/h1&gt;</div><div class="line">			&lt;/div&gt;</div><div class="line">		);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// teacher.js</div><div class="line">import React from &quot;react&quot;;</div><div class="line">export default class Teacher extends React.Component &#123;</div><div class="line">	constructor(props) &#123;</div><div class="line">		super(props);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	render() &#123;</div><div class="line">		return (</div><div class="line">			&lt;div&gt;</div><div class="line">				&lt;h1&gt;教师管理&lt;/h1&gt;</div><div class="line">			&lt;/div&gt;</div><div class="line">		);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// emp.js</div><div class="line">import React from &quot;react&quot;;</div><div class="line">export default class Emp extends React.Component &#123;</div><div class="line">	constructor(props) &#123;</div><div class="line">		super(props);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	render() &#123;</div><div class="line">		return (</div><div class="line">			&lt;div&gt;</div><div class="line">				&lt;h1&gt;员工管理&lt;/h1&gt;</div><div class="line">			&lt;/div&gt;</div><div class="line">		);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>组件创建完成之后, 下一步定义 <code>url</code> 和组件之间的映射关系.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/                   Login</div><div class="line">/reg                Reg</div><div class="line">/info               Info</div><div class="line">/info/emp           Info -&gt; Emp</div><div class="line">/info/student       Info -&gt; Student</div><div class="line">/info/teacher       Info -&gt; Teacher</div><div class="line">/info/system        Info -&gt; System</div></pre></td></tr></table></figure>
<p>在这个应用中, 一共3个一级路径, 分别为根路径, <code>/reg</code>和<code>/info</code>. 在<code>/info</code>下又包含4个二级路径. <code>url</code>和组件的映射关系确定之后, 我们在<code>app.js</code>中来完成这些配置. </p>
<h4 id="2-HashRouter-和-Route"><a href="#2-HashRouter-和-Route" class="headerlink" title="2. HashRouter 和 Route"></a>2. HashRouter 和 Route</h4><p>首先实现一级页面的导航. 这里我们使用<code>HashRouter</code>和<code>Route</code>组件来配置路由. 引入这两个组件. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; HashRouter <span class="keyword">as</span> Router, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></div></pre></td></tr></table></figure>
<p><code>HashRouter</code> 组件是基于 <code>hashHistory</code> 的路由管理方案, 通过监听<code>URL hash</code>值的变化来动态的渲染组件. <code>Route</code>组件则是用来配置路径与组件之间的关系. 当匹配成功之后, 加载相对应的组件. 下面我们就来配置应用的路由.</p>
<p><code>Router</code>组件作为一个路由的容器组件, 可以在其内部通过 <code>Route</code> 配置多个映射关系. 但这里需要注意的是, 在<code>Router</code>组件中,只能出现一个子元素. 当有多个子元素时, 我们会使用一个元素给包裹起来. </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const myRouter = (</div><div class="line">	<span class="tag">&lt;<span class="name">Router</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">		  // 多个子组件时, 要使用一个元素将其包裹起来</div><div class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">Router</span>&gt;</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>我们可以在 <code>Route</code> 组件上使用<code>path</code>属性表示可匹配的有效<code>url</code>, 然后使用<code>component</code>属性表示该<code>url</code>所对应的组件. 那这里, 我们首先添加 <code>login</code>, <code>reg</code> 和 <code>info</code> 的映射关系. </p>
<p>分别引入这3个组件, 然后在<code>Router</code>组件中对根路径, <code>/reg</code>和<code>/info</code>进行配置.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// app.js</div><div class="line">import Login from <span class="string">"./components/login.js"</span></div><div class="line">import Reg from <span class="string">"./components/reg.js"</span></div><div class="line">import Info from <span class="string">"./components/info/info.js"</span></div><div class="line"></div><div class="line">// 添加映射关系</div><div class="line">const myRouter = (</div><div class="line">	&lt;Router&gt;</div><div class="line">		&lt;div&gt;</div><div class="line">           &lt;Route path=<span class="string">"/"</span> component=&#123; Login &#125;&gt;&lt;/Route&gt;</div><div class="line">           &lt;Route path=<span class="string">"/reg"</span> component=&#123; Reg &#125;&gt;&lt;/Route&gt;</div><div class="line">           &lt;Route path=<span class="string">"/info"</span> component=&#123; Info &#125;&gt;&lt;/Route&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">	&lt;/Router&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>配置完成之后, 可以看到浏览器已经成功加载登录页面. 同时, 地址栏也已经变成hash值的格式.<br>这时, 修改<code>hash</code>值, 观察页面的变化.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ --&gt; /reg</div></pre></td></tr></table></figure>
<h4 id="3-Route-的-exact-属性"><a href="#3-Route-的-exact-属性" class="headerlink" title="3. Route 的 exact 属性"></a>3. Route 的 exact 属性</h4><p>我们将<code>url</code>从根路径修改成<code>/reg</code>, 这时, 在index.html页面中同时显示了登录和注册页面. 我们再将<code>/reg</code>修改成<code>/info</code>, 页面又显示了登录和信息管理. 那这里为什么一个url会显示2个视图呢?原因是: <code>route</code>在做路径匹配时, 会将当前的路径与配置所有路径一一匹配, 如果包含的话就会认为匹配成功. 因此, 当我们访问<code>/reg</code>或<code>/info</code>时, 根路径总会匹配成功. 如果要避免这种情况, 我们可以在<code>Route</code>上配置<code>exact</code>属性,来实现精确匹配.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Route exact path=&quot;/&quot; component=&#123; Login &#125;&gt;&lt;/Route&gt;</div></pre></td></tr></table></figure>
<p>这时, 页面就可以在<code>login</code>, <code>reg</code>和<code>info</code>之间相互切换了.</p>
<p>我们除了可以通过修改<code>url</code>的值来切换视图以外, 还可以通过事件来触发视图的切换. 接下来, 在<code>Login</code>组件中, 给登录按钮和注册按钮添加点击事件, 点击之后分别跳转到相对应的页面. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// login.js</div><div class="line"></div><div class="line">login() &#123;</div><div class="line">	const &#123;</div><div class="line">		history</div><div class="line">	&#125; = this.props</div><div class="line">	history.push(&quot;/info&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">reg() &#123;</div><div class="line">	const &#123;</div><div class="line">		history</div><div class="line">	&#125; = this.props</div><div class="line">	history.push(`/reg`)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义 <code>login</code> 函数. 只要配置过映射关系的这些组件, 我们都可以在组件中通过<code>props</code>属性获取<code>Route</code>传递进来的参数. 在这些参数中, <code>history</code>对象就可以用来实现跳转. 他有一个<code>push</code>方法, 接收一个<code>url</code>作为参数, 当方法调用时, 页面就会跳转到指定的<code>url</code>. 这里, 当用户点击登录按钮时, 我们让视图切换到<code>/info</code>的路径, 也就是信息管理页面. 同理, 当用户点击注册按钮时, 切换到注册页面. 完成后, 点击登录注册按钮, 页面可以切换到相对应的视图.</p>
<h4 id="4-Route-配置动态参数"><a href="#4-Route-配置动态参数" class="headerlink" title="4. Route 配置动态参数"></a>4. Route 配置动态参数</h4><p>有时候, 还有这样的一些应用: 我们需要在一些页面中获取某个值, 然后将这个值传递到另一个页面中展示出来. 通常情况下, 我们可以使用<code>url</code>来记录需要传递的这些数据. <code>react-router</code>也为我们提供了一种配置方式, 来获取这些动态产生的数据.</p>
<p>我们新增一个路由配置. </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/login/:username"</span> <span class="attr">component</span>=<span class="string">&#123;</span> <span class="attr">Login</span> &#125;&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></div></pre></td></tr></table></figure>
<p>注意, 在配置<code>path</code>属性时, <code>/login/</code>路径后面多了一个<code>:username</code>. 这种路径的表现方式, 意味这用户在访问<code>/login</code>时, 可以在这个路径后携带上一个参数, 然后在这个路径对应的组件中, 我们就可以使用冒号后面的标识符来获取携带的参数值.</p>
<p>这里, 我们让用户在注册页面输入账户信息, 然后点击登录按钮, 跳转到登录页面, 同时, 系统将用户输入的账户名在登录的账户输入框中显示出来. </p>
<ul>
<li>首先在注册页面中, 点击登录按钮时, 获取用户输入的账户名, 我们可以使用<code>refs</code>属性来获取输入框的值.</li>
<li><p>拿到用户输入的值之后, 接下来调用<code>history.push()</code>方法完成页面的跳转. 这时, 需要跳转的路径我们就可以这样来设置: </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">history.push(`/login/$&#123;this.refs.username.value&#125;`)</div></pre></td></tr></table></figure>
<p>  我们可以将用户输入的值拼接在<code>/login/</code>路径后面.点击登录按钮之后,<code>url</code>变成<code>/login</code>加上用户输入的字符串.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:8080/#/login/zhangsan</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>下一步我们来获取这个参数. 在<code>Login</code>组件中, 我们可以使用路由传递的<code>match</code>对象来获取这个参数值. 展开这个对象, 可以看到有一个<code>params</code>的属性, 其中<code>username</code>就是从<code>url</code>携带的参数值. 拿到这个参数后, 就可以直接渲染在页面上了.</li>
</ul>
<h4 id="5-Route-render-方法和重定向-Redirect"><a href="#5-Route-render-方法和重定向-Redirect" class="headerlink" title="5. Route render 方法和重定向 Redirect"></a>5. Route render 方法和重定向 Redirect</h4><p><code>Route</code>组件除了可以使用<code>component</code>属性来指定路径对应的组件以外, 还可以使用<code>render</code>属性来处理路径与组件的映射关系. <code>render</code>属性接受一个函数, 当路径匹配成功之后, 该函数被调用. 同时, <code>Route</code>组件会把本身传递给组件的这些参数传递给这个函数.</p>
<p>这里我们假设, <code>isLogin</code>变量用来标志用户的登录状态, <code>true</code>表示已登录, <code>false</code>表示未登录, 默认值为 <code>false</code>. 我们只允许用户在登录状态下访问<code>/info</code>以及<code>/info</code>下的子页面. 这时, 就可以在<code>render</code>方法中对登录状态进行判断. </p>
<p>当<code>isLogin</code>状态为<code>true</code>时, 我们直接返回<code>info</code>组件, 同时, 将<code>props</code>参数传递进去. 当状态为<code>false</code>时, 将路径导航到登录页面. <code>react-router</code>提供了一个<code>Redirect</code>组件专门用来实现路径的重定向, 我们只需要配置其<code>to</code>的属性, 指定新的地址就可以完成重定向. 这里, 我们重定向到根路径.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 登录状态</div><div class="line">let isLogin = false;</div><div class="line"></div><div class="line">&lt;Route path=&quot;/info&quot; render=&#123;(props) =&gt; &#123;</div><div class="line">	return isLogin ? &lt;Info &#123;...props&#125; /&gt; : &lt;Redirect to=&quot;/&quot; /&gt;</div><div class="line">&#125;&#125;&gt;&lt;/Route&gt;</div></pre></td></tr></table></figure>
<ul>
<li>当前<code>isLogin</code>状态为<code>false</code>, 意味着用户没有登录, 当点击登录按钮时, 页面不会跳转到<code>info</code>界面.</li>
<li>修改<code>isLogin</code>为<code>true</code>, 再次点击登录按钮, 可以看到, 页面成功跳转的<code>info</code>界面.</li>
</ul>
<p>这里提醒大家的是, 当<code>Route</code>组件上, <code>render</code>属性和<code>component</code>属性同时存在时, <code>component</code>的优先级要高于<code>render</code>.<code>render</code>方法会无效.</p>
<h4 id="6-Link-和-NavLink-声明式导航"><a href="#6-Link-和-NavLink-声明式导航" class="headerlink" title="6. Link 和 NavLink 声明式导航"></a>6. Link 和 NavLink 声明式导航</h4><p>接下来, 我们再来看看, 在<code>info</code>页面中嵌套路由的用法.</p>
<p>在<code>info</code>中包含4个子页面, 分别为学生信息, 教师信息, 员工信息和系统信息. 首先引入这些组件. 这里, 我们通过导航栏的形式,来显示这些页面. 整个<code>info</code>页面分成左右两个部分, 左侧为页面导航部分, 当前<code>url</code>所对应的视图在右侧显示. 咱们首先来添加导航栏.<br><code>react-router</code>提供了一个<code>Link</code>组件来实现这种声明式导航. 我们只需要在<code>li</code>元素中使用这个组件即可. 该组件通过<code>to属性</code>来配置需要导航的路径. </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&#123;&#123;...styles.infoNav&#125;&#125;</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">info</span>/<span class="attr">teacher</span>`&#125; &gt;</span>教师管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">info</span>/<span class="attr">emp</span>`&#125; &gt;</span>员工管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">info</span>/<span class="attr">student</span>`&#125; &gt;</span>学生管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">info</span>/<span class="attr">system</span>`&#125; &gt;</span>系统管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>导航栏配置完成. 接下来, 我们在右侧区域, 使用<code>Route</code>组件配置路径和组件的映射关系. </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>`/<span class="attr">info</span>/<span class="attr">teacher</span>`&#125; <span class="attr">component</span>=<span class="string">&#123;Teacher&#125;</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>`/<span class="attr">info</span>/<span class="attr">emp</span>`&#125; <span class="attr">component</span>=<span class="string">&#123;Emp&#125;</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>`/<span class="attr">info</span>/<span class="attr">student</span>`&#125; <span class="attr">component</span>=<span class="string">&#123;Student&#125;</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>`/<span class="attr">info</span>/<span class="attr">system</span>`&#125; <span class="attr">component</span>=<span class="string">&#123;System&#125;</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>使用方法和刚刚的配置方法一样, <code>path</code>属性用来指定路径, <code>component</code>属性用来指定该路径映射的组件.<br>配置完成之后, 我们就可以通过导航栏来切换视图了.</p>
<p>除了<code>Link</code>组件以外, <code>react-router</code>还提供了一个<code>NavLink</code>用来实现导航, 使用这个组件, 当url匹配成功之后, 它会给导航按钮添加指定的样式.</p>
<p>我们将<code>Link</code>替换成<code>NavLink</code>, 这个组件通过<code>activeClassName</code>或<code>activeStyle</code>属性来为激活状态下的按钮添加样式. 这里我们使用<code>activeStyle</code>属性, 设置激活状态下导航按钮的字体颜色为红色.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&#123;&#123;...styles.infoNav&#125;&#125;</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">info</span>/<span class="attr">teacher</span>`&#125; &gt;</span>教师管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">info</span>/<span class="attr">emp</span>`&#125; &gt;</span>员工管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">info</span>/<span class="attr">student</span>`&#125; &gt;</span>学生管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">info</span>/<span class="attr">system</span>`&#125; &gt;</span>系统管理<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tangzhenh.com/2017/06/02/react-router-v4-x/" data-id="cj3fmdos30001dqnrtlkb82ny" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-symbol" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/02/symbol/" class="article-date">
  <time datetime="2017-06-02T08:18:11.000Z" itemprop="datePublished">2017-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/02/symbol/">symbol</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="1-Symbol-是个啥"><a href="#1-Symbol-是个啥" class="headerlink" title="1. Symbol 是个啥?"></a>1. Symbol 是个啥?</h2><p><code>ES6</code> 规范之前, <code>JavaScript</code> 一共有六种数据类型, 分别为 <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>null</code>, <code>undefined</code> 和 <code>Object</code>(引用类型).在<code>ES6</code>中,新增了一种数据类型 <code>Symbol</code>, 用来表示独一无二的值.<br>在<code>js</code>中, 我们可以随意的给对象添加属性或方法, 这种操作对象的方式, 很容易会产生属性名冲突的情况. 这时, 利用<code>Symbol</code>的特性, 就可以给对象添加独一无二的属性了.</p>
<h2 id="2-如何生成一个-Symbol-值"><a href="#2-如何生成一个-Symbol-值" class="headerlink" title="2. 如何生成一个 Symbol 值?"></a>2. 如何生成一个 Symbol 值?</h2><p><code>Symbol</code>是一个函数,如果我们想要得到一个<code>Symbol值</code>, 只需要调用该函数即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 创建symbol值</div><div class="line">const s1 = Symbol();</div><div class="line">const s2 = Symbol();</div></pre></td></tr></table></figure>
<p><code>s1和s2</code>就是两个<code>Symbol值</code>. 每次<code>Symbol函数</code>调用,都会得到一个不同的<code>Symbol值</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 唯一性</div><div class="line">s1 === s2 // false</div></pre></td></tr></table></figure>
<p>在控制台上打印<code>s1, s2</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(s1, s2) //Symbol() Symbol()</div></pre></td></tr></table></figure>
<p>控制台会输出两个<code>Symbol()</code>字符串, 用来表示<code>s1</code>和<code>s2</code>的值. 通过这个两个字符串, 我们无法区分到底谁是<code>s1</code>, 谁是<code>s2</code>. 因此, 在调用<code>Symbol函数</code>时, 我们通常会传递一个字符串类型的参数, 用来描述创建的<code>Symbol值</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const s1 = Symbol(&quot;s1&quot;);</div><div class="line">const s2 = Symbol(&quot;s2&quot;);</div><div class="line"></div><div class="line">console.log(s1, s2); //Symbol(s1) Symbol(s2)</div></pre></td></tr></table></figure>
<p>这时, 我们就可以根据描述来区分不同的值了. </p>
<p>注意: <code>Symbol函数</code>的参数只是表示对当前<code>Symbol值</code>的描述，相同参数的<code>Symbol函数</code>返回值依然是不相同的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s1 = Symbol(&apos;foo&apos;);</div><div class="line">var s2 = Symbol(&apos;foo&apos;);</div><div class="line"></div><div class="line">s1 === s2 // false</div></pre></td></tr></table></figure>
<h2 id="3-Symbol-for-Symbol-keyFor"><a href="#3-Symbol-for-Symbol-keyFor" class="headerlink" title="3. Symbol.for, Symbol.keyFor"></a>3. Symbol.for, Symbol.keyFor</h2><p><code>Symbol()</code>方法每次调用都会返回一个新的属性值. 有时, 我们希望重新使用同一个<code>Symbol值</code>, 就可以通过<code>Symbol.for</code>方法来创建. 该方法接受一个字符串为参数. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 使用 Symbol.for()方法生成 Symbol 类型的值</div><div class="line"></div><div class="line">var s1 = Symbol.for(&apos;foo&apos;); // 没有找到描述为foo的Symbol值, 则创建新的Symbol值</div><div class="line">var s2 = Symbol.for(&apos;foo&apos;); // 找到描述为foo的Symbol值, 则返回</div><div class="line"></div><div class="line">s1 === s2 // true</div></pre></td></tr></table></figure>
<p>以上代码中, <code>s1</code>和<code>s2</code>都是<code>Symbol值</code>, 而且是通过<strong>相同参数(foo)的Symbol.for方法</strong>生成的, 实际上就是同一个值. <code>Symbol.for</code>的生成规则是: 首先在全局环境中查找有没有使用某个字符串注册的<code>Symbol值</code>,如果有的话就会返回找到的那个值,如果没有的话就会重新创建一个. 这样做的目的使我们可以重复使用之前定义过的<code>Symbol值</code>，或者修改与之相关的一些东西. </p>
<blockquote>
<p>比较: <code>Symbol()</code>和<code>Symbol.for()</code>都会产生<code>Symbol值</code>, 前者每次都产生新的<code>Symbol值</code>, 不管有没有参数. 后者在创建<code>Symbol值</code>之前, 会在全局环境中搜索注册的<code>Symbol值</code>, 如果不存在才会创建新的.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Symbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;)</div><div class="line">// true</div><div class="line"></div><div class="line">Symbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;)</div><div class="line">// false</div></pre></td></tr></table></figure>
<p><code>Symbol.keyFor</code>方法用来返回<code>Symbol值</code>的注册信息.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var s1 = Symbol.for(&quot;foo&quot;);</div><div class="line">Symbol.keyFor(s1) // &quot;foo&quot;</div></pre></td></tr></table></figure>
<p>这个方法需要和<code>Symbol.for</code>配合使用. 如果你是使用<code>Symbol()</code>函数创建的<code>Symbol值</code>, 不论你传不传递参数, 通过<code>Symbol.keyFor()</code>函数是查找不到它的注册信息的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var s2 = Symbol(&quot;foo&quot;);</div><div class="line">Symbol.keyFor(s2) // undefined</div></pre></td></tr></table></figure>
<h2 id="4-使用Symbol来定义对象的属性"><a href="#4-使用Symbol来定义对象的属性" class="headerlink" title="4. 使用Symbol来定义对象的属性"></a>4. 使用<code>Symbol</code>来定义对象的属性</h2><p><code>ES5</code> 的对象属性名都是字符串，这容易造成属性名的冲突。比如, 在某些应用场景下, 你需要使用别人提供的对象, 有时, 还想为这个对象添加一些属性或方法, 那么新添加的这些属性或方法就有可能和现有的产生冲突. 由于<code>Symbol值</code>的唯一性, 这意味着我们可以使用<code>Symbol值</code>来作为对象的属性名, 这样就可以保证对象不会出现同名的情况.</p>
<p><strong>使用<code>Symbol值</code>作为对象的属性</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var mySymbol = Symbol();</div><div class="line"></div><div class="line">// 第一种写法</div><div class="line">var a = &#123;&#125;;</div><div class="line">a[mySymbol] = &apos;Hello!&apos;;</div><div class="line"></div><div class="line">// 第二种写法</div><div class="line">var a = &#123;</div><div class="line">  [mySymbol]: &apos;Hello!&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 第三种写法</div><div class="line">var a = &#123;&#125;;</div><div class="line">Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;);</div><div class="line"></div><div class="line">// 以上写法都得到同样结果</div><div class="line">a[mySymbol] // &quot;Hello!&quot;</div></pre></td></tr></table></figure>
<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const COLOR_RED    = Symbol();</div><div class="line">const COLOR_GREEN  = Symbol();</div><div class="line"></div><div class="line">function getComplement(color) &#123;</div><div class="line">  switch (color) &#123;</div><div class="line">    case COLOR_RED:</div><div class="line">      return COLOR_GREEN;</div><div class="line">    case COLOR_GREEN:</div><div class="line">      return COLOR_RED;</div><div class="line">    default:</div><div class="line">      throw new Error(&apos;Undefined color&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-遍历Symbol定义的属性"><a href="#5-遍历Symbol定义的属性" class="headerlink" title="5. 遍历Symbol定义的属性"></a>5. 遍历<code>Symbol</code>定义的属性</h2><p>使用<code>Symbol</code>定义的属性, 是无法在<code>for...in</code>, <code>Object.keys()</code>, <code>Object.getOwnPropertyNames()</code>方法中被返回:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const obj = &#123;</div><div class="line">	[Symbol(&quot;username&quot;)]: &quot;zhangsan&quot;,</div><div class="line">	[Symbol(&quot;password&quot;)]: &quot;11111&quot;,</div><div class="line">	age: 21</div><div class="line">&#125;;</div><div class="line"></div><div class="line">for (let attr in obj) &#123;</div><div class="line">	console.log(attr) // age</div><div class="line">&#125;</div><div class="line"></div><div class="line">Object.keys(obj) // [&quot;age&quot;]</div><div class="line"></div><div class="line">Object.getOwnPropertyNames(obj) // [&quot;age&quot;]</div></pre></td></tr></table></figure>
<p>以上的代码, 都只会返回<code>obj</code>的<code>age</code>属性. 想要获取对象<code>Symbol</code>定义的属性, 我们可以使用<code>Object.getOwnPropertySymbols()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertySymbols(obj) // (2) [Symbol(username), Symbol(password)]</div></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertySymbols()</code>方法返回一个数组，成员是当前对象的所有用作属性名的 <code>Symbol 值</code>。除了以上方法可以获取到对象的<code>Symbol</code>属性以外, 还可以使用<code>Reflect.ownKeys()</code>方法获取对象所有的属性: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Reflect.ownKeys(obj) //(3) [&quot;age&quot;, Symbol(username), Symbol(password)]</div></pre></td></tr></table></figure>
<p>这时, 就可以获取到对象的全部属性了.</p>
<h2 id="6-内置的Symbol值"><a href="#6-内置的Symbol值" class="headerlink" title="6. 内置的Symbol值"></a>6. 内置的<code>Symbol值</code></h2><p>除了定义自己使用的<code>Symbol值</code>以外，ES6还提供了11个内置的Symbol值. </p>
<h4 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h4><p><code>Symbol.iterator</code> 用来表示迭代器, 只要对象实现这个接口, 就可以使用<code>for...of</code>方式进行遍历. 已有的集合类型, 数组, <code>Set</code>和<code>Map</code>, 默认就实现了这个接口, 因此他们可以通过<code>for...of</code>来遍历. 除此以外, 在E6中, 想要使用<code>for...of</code>遍历一个<code>Object</code>对象, 就需要这个对象实现<code>Symbol.iterator</code>接口.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tangzhenh.com/2017/06/02/symbol/" data-id="cj3fmdorz0000dqnro4h08wen" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/02/react-router-v4-x/">react-router_v4.x 使用</a>
          </li>
        
          <li>
            <a href="/2017/06/02/symbol/">symbol</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 tangzhenh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>