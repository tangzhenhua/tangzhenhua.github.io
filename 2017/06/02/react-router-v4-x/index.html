<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>react-router_v4.x | ^_^</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在 web 应用开发中，路由系统是不可或缺的一部分。当浏览器的 URL 发生变化时，意味着用户产生了新的请求, 路由系统会根据请求资源的路径, 将这些请求分发给与之对应的服务进行处理.">
<meta property="og:type" content="article">
<meta property="og:title" content="react-router_v4.x">
<meta property="og:url" content="http://tangzhenh.com/2017/06/02/react-router-v4-x/index.html">
<meta property="og:site_name" content="^_^">
<meta property="og:description" content="在 web 应用开发中，路由系统是不可或缺的一部分。当浏览器的 URL 发生变化时，意味着用户产生了新的请求, 路由系统会根据请求资源的路径, 将这些请求分发给与之对应的服务进行处理.">
<meta property="og:updated_time" content="2017-06-02T08:33:12.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="react-router_v4.x">
<meta name="twitter:description" content="在 web 应用开发中，路由系统是不可或缺的一部分。当浏览器的 URL 发生变化时，意味着用户产生了新的请求, 路由系统会根据请求资源的路径, 将这些请求分发给与之对应的服务进行处理.">
  
    <link rel="alternate" href="/atom.xml" title="^_^" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">^_^</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://tangzhenh.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-react-router-v4-x" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/02/react-router-v4-x/" class="article-date">
  <time datetime="2017-06-02T08:20:18.000Z" itemprop="datePublished">2017-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      react-router_v4.x
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 <code>web</code> 应用开发中，路由系统是不可或缺的一部分。当浏览器的 <code>URL</code> 发生变化时，意味着用户产生了新的请求, 路由系统会根据请求资源的路径, 将这些请求分发给与之对应的服务进行处理.</p>
<a id="more"></a>
<h3 id="传统-Web-开发方式"><a href="#传统-Web-开发方式" class="headerlink" title="传统 Web 开发方式"></a>传统 Web 开发方式</h3><p>在传统的网页应用架构中，用户通过浏览器, 将请求发送给服务端.<br>在服务端有一个叫控制器的东西, 负责统一处理前端的请求, 其中就包含了路由的分发. 控制器中维护了一套路由列表, 里面配置的是, 请求路径与服务方法的映射关系. 当控制器接收到用户请求之后, 根据请求的路径, 调用与之对应的服务方法. 服务再根据某些业务规则,完成数据的处理, 最后生成新的页面返回给浏览器. </p>
<p>比如, 当用户请求 <code>/users/login</code> 时, 控制器在路由列表中匹配到这个路径, 同时调用 <code>loginService</code> 方法进行业务处理, 处理完成之后, 将处理完成之后的数据加上页面返回给浏览器端. 浏览器直接拿到页面后完成渲染. </p>
<p>在这样的架构中, 浏览器实际上就只是一个展示数据的地方, 路由配置, 服务的调用, 以及页面跳转的流程都是由服务端来完成. </p>
<p>以上是传统的网页应用方式, 可以看到, 在这种方式下, 开发的重心都偏向于服务端, 浏览器只是用于数据的展示. 而且, 当页面数据需要更新时, 会刷新整个页面, 这会导致资源的浪费.</p>
<p>下面我们再来看看单页应用的开发方式.</p>
<h3 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h3><p>相对于传统的网页应用, 在单页的方式下, 控制器被前置到浏览器端, 也就是说, 当浏览器的访问地址发生变化时, 请求不在是发送到服务端, 而是在浏览器端直接响应. 同时, 视图的更新也不在是从一个页面跳转到另一个页面. 取而代之的是, 使用一个组件替换另一个组件. 原先的服务端则逐渐简化成一个单纯提供数据的服务, 供浏览器调用. </p>
<h3 id="如何创建一个前端路由"><a href="#如何创建一个前端路由" class="headerlink" title="如何创建一个前端路由"></a>如何创建一个前端路由</h3><p>前端路由在功能上实际和服务端路由是一样的. 通过路由列表来维护用户访问路径和组件之间的关系. 我们可以利用 <code>url</code> 中的 <code>hash</code> 属性和 <code>HTML5</code> 中的 <code>history API</code> 来创建前端路由. </p>
<p>下面我们首先来看一下 <code>hash</code> 的特性</p>
<h4 id="1-hash-属性"><a href="#1-hash-属性" class="headerlink" title="1. hash 属性"></a>1. hash 属性</h4><p><code>url</code> 中的 <code>hash</code> 属性表示网页中的一个位置. 其 <code>#</code> 后面的字符, 就是 <code>hash</code> 属性的值. 也就是我们经常所说的锚点. 比如下面这个访问地址: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.example.com/index.html/#login</div></pre></td></tr></table></figure>
<p>这个 <code>url</code> 就表示需要访问 <code>index.html</code> 页面中的 <code>login</code> 位置. 浏览器在加载 <code>index.html</code> 页面完成之后, 会自动将页面中 <code>login</code> 位置的内容显示出来. </p>
<p>hash 属性除了可以用来实现页内导航以外, 还有一个重要的特性, 就是当 hash 值发生改变时, 不会引起页面的刷新. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.example.com/index.html/#reg</div></pre></td></tr></table></figure>
<p>比如, 用户将 <code>login</code> 改成 <code>reg</code>, 浏览器会定位到新的位置, 而不会重新加载网页. 并且每一次改变 <code>hash</code> 值, 都会在浏览器的访问历史中增加一个记录, 使用”后退”按钮, 就可以回到上一个位置.</p>
<p>下面, 我们根据 <code>hash</code> 属性, 来创建一个基础的路由系统.</p>
<p>我们需要在 <code>index.html</code> 页面中完成登录界面, 注册界面和信息界面的相互切换. </p>
<p>首先看一下<code>url</code>和视图之间的映射关系: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">http://www.example.com/index.html/#login 访问登录界面</div><div class="line">http://www.example.com/index.html/#reg 访问注册界面</div><div class="line">http://www.example.com/index.html/#info 访问信息界面</div></pre></td></tr></table></figure>
<ul>
<li><code>#login</code>用来标志访问登录界面, <code>#reg</code>表示注册界面, <code>#info</code>则是信息界面</li>
<li>首先在<code>index.html</code>页面中, 添加一个<code>div</code>, 作为视图容器. 当用户访问不同的<code>url</code>时, 容器就显示对应的视图. </li>
<li>然后创建路由处理函数. 通过 <code>location.hash</code> 获取到当前的 <code>hash</code> 值进行路径匹配, 匹配成功之后, 返回对应的视图, 否则返回登录界面. 这里我们使用 <code>switch</code> 来进行匹配</li>
<li>最后, 添加事件监听. 在<code>HTML 5</code>中, 新增了一个 <code>onhashchange</code> 的事件, 当 <code>hash</code> 值发生改变时, 就会触发这个事件. 这里, 我们添加这个事件, 当事件触发时, 调用路由处理函数.</li>
<li>打开浏览器, 刷新页面, 修改<code>hash</code>值, 这时, 页面会随着<code>url</code>的改变切换到与之对应的视图.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function router() &#123;</div><div class="line">	const hash = location.hash</div><div class="line">	switch(hash) &#123;</div><div class="line">		case &quot;#login&quot;:</div><div class="line">			app.innerHTML = `&lt;h1&gt;登录界面&lt;/h1&gt;`</div><div class="line">			return;</div><div class="line">		case &quot;#reg&quot;:</div><div class="line">			app.innerHTML = `&lt;h1&gt;注册界面&lt;/h1&gt;`</div><div class="line">			return;</div><div class="line">		case &quot;#info&quot;:</div><div class="line">			app.innerHTML = `&lt;h1&gt;信息界面&lt;/h1&gt;`</div><div class="line">			return;</div><div class="line">		default:</div><div class="line">			app.innerHTML = `&lt;h1&gt;信息界面&lt;/h1&gt;`</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">router()</div><div class="line"></div><div class="line">window.addEventListener(&quot;hashchange&quot;, function() &#123;</div><div class="line">	router()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>以上就是通过 <code>hash</code> 属性, 创建的一个最简单的路由系统.</p>
<p>除了 <code>hash</code> 属性之外, 我们还可以通过<code>HTML5</code>中的<code>history API</code>来创建路由系统.</p>
<h4 id="2-HTML-5-history"><a href="#2-HTML-5-history" class="headerlink" title="2. HTML 5 history"></a>2. HTML 5 history</h4><p>在<code>HTML 5</code>中, 我们可以使用<code>pushState</code>方法来实现路由. </p>
<p> <code>pushState</code>方法用来修改<code>url</code>, 并将最新的 <code>url</code> 添加到历史记录. 该方法接收3个参数, 第一个参数是状态对象<code>(state object)</code>, 用来描述当前历史记录. 第二个参数为标题<code>title</code>. 第三个<code>url</code>, 这个参数提供了新历史记录的地址. </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">history.pushState(&#123;&#125;, null, &quot;/login&quot;)</div></pre></td></tr></table></figure>
<p>例如, 当用户访问<code>index.html</code>页面时, 调用<code>pushState</code>方法,<br>浏览器做了2件事情:</p>
<ul>
<li><p>第一, 将<code>url</code>路径修改成用户指定的地址,也就是<code>/login</code> </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:3001/index.html -&gt; http://localhost:3001/login</div></pre></td></tr></table></figure>
</li>
<li><p>第二, 将这个地址添加到历史记录.</p>
</li>
</ul>
<p>这里需要注意一下的是, 当浏览器调用<code>pushState</code>方法操作<code>url</code>的时候, 浏览器只会修改<code>url</code>路径, 不会根据<code>url</code>请求服务端, 这时我们就可以进行视图的切换. 但是如果用户直接通过地址栏输入的方式来访问该地址的时候, 这时浏览器会根据访问的路径去请求服务端获取资源. 因此, 使用这种方式来实现路由, 还需要后台服务器与之配合完成.</p>
<p>以上两种就是常见的路由实现方式, 很多前端路由就是基于以上的方式在实现, 其中就包括<code>react-router</code>. 下面我们来看看, 在单页开发中, 如何使用<code>react-router</code>提供的路由功能.</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先在项目中安装 <code>react-router</code> 依赖, <code>V4.X</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 4.0 版本以上</div><div class="line">npm install react-router-dom --save</div></pre></td></tr></table></figure>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><h4 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h4><p>接下来, 我们要来实现一个包含登录, 注册以及信息管理功能的应用, 整个应用的结构如下: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">index.html  // 主页面</div><div class="line">src</div><div class="line"> │  app.js  // 应用入口程序</div><div class="line"> └─ components </div><div class="line">     │  login.js    // 登录组件    </div><div class="line">     │  reg.js      // 注册组件</div><div class="line">     └─ info</div><div class="line">             emp.js     // 员工组件</div><div class="line">             student.js // 学生组件</div><div class="line">             system.js  // 系统组件</div><div class="line">             teacher.js // 教师组件</div></pre></td></tr></table></figure>
<ul>
<li><code>index.html</code> 是应用的主页面, 因为采用单页开发的方式, 因此整个应用的视图都在这个页面进行切换展示. </li>
<li><code>app.js</code> 是整个应用的入口程序, 用来整合和配置该应用的其他组件. </li>
<li><code>components</code> 目录用来存放整个应用的组件.</li>
<li>其中 <code>login.js</code> 为登录组件</li>
<li><code>reg.js</code> 为注册组件</li>
<li><code>info</code> 目录, 存放信息管理模块的相关组件, 其中 <code>emp.js</code> 是员工组件, <code>student.js</code> 学生组件, <code>system.js</code> 系统组件, <code>teacher.js</code> 教师组件.  </li>
</ul>
<p>整个应用的结构, 以及包含的主要模块大致如上, 首先在项目中创建这些组件. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">// student.js</div><div class="line">import React from &quot;react&quot;;</div><div class="line">export default class Student extends React.Component &#123;</div><div class="line">	constructor(props) &#123;</div><div class="line">		super(props);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	render() &#123;</div><div class="line">		return (</div><div class="line">			&lt;div&gt;</div><div class="line">				&lt;h1&gt;学生管理&lt;/h1&gt;</div><div class="line">			&lt;/div&gt;</div><div class="line">		);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// system.js</div><div class="line">import React from &quot;react&quot;;</div><div class="line">export default class System extends React.Component &#123;</div><div class="line">	constructor(props) &#123;</div><div class="line">		super(props);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	render() &#123;</div><div class="line">		return (</div><div class="line">			&lt;div&gt;</div><div class="line">				&lt;h1&gt;系统管理&lt;/h1&gt;</div><div class="line">			&lt;/div&gt;</div><div class="line">		);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// teacher.js</div><div class="line">import React from &quot;react&quot;;</div><div class="line">export default class Teacher extends React.Component &#123;</div><div class="line">	constructor(props) &#123;</div><div class="line">		super(props);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	render() &#123;</div><div class="line">		return (</div><div class="line">			&lt;div&gt;</div><div class="line">				&lt;h1&gt;教师管理&lt;/h1&gt;</div><div class="line">			&lt;/div&gt;</div><div class="line">		);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// emp.js</div><div class="line">import React from &quot;react&quot;;</div><div class="line">export default class Emp extends React.Component &#123;</div><div class="line">	constructor(props) &#123;</div><div class="line">		super(props);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	render() &#123;</div><div class="line">		return (</div><div class="line">			&lt;div&gt;</div><div class="line">				&lt;h1&gt;员工管理&lt;/h1&gt;</div><div class="line">			&lt;/div&gt;</div><div class="line">		);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>组件创建完成之后, 下一步定义 <code>url</code> 和组件之间的映射关系.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/                   Login</div><div class="line">/reg                Reg</div><div class="line">/info               Info</div><div class="line">/info/emp           Info -&gt; Emp</div><div class="line">/info/student       Info -&gt; Student</div><div class="line">/info/teacher       Info -&gt; Teacher</div><div class="line">/info/system        Info -&gt; System</div></pre></td></tr></table></figure>
<p>在这个应用中, 一共3个一级路径, 分别为根路径, <code>/reg</code>和<code>/info</code>. 在<code>/info</code>下又包含4个二级路径. <code>url</code>和组件的映射关系确定之后, 我们在<code>app.js</code>中来完成这些配置. </p>
<h4 id="2-HashRouter-和-Route"><a href="#2-HashRouter-和-Route" class="headerlink" title="2. HashRouter 和 Route"></a>2. HashRouter 和 Route</h4><p>首先实现一级页面的导航. 这里我们使用<code>HashRouter</code>和<code>Route</code>组件来配置路由. 引入这两个组件. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import &#123;</div><div class="line">	HashRouter as Router, </div><div class="line">	Route</div><div class="line">&#125; from &apos;react-router-dom&apos;</div><div class="line">``` </div><div class="line"></div><div class="line">`HashRouter` 组件是基于 `hashHistory` 的路由管理方案, 通过监听`URL hash`值的变化来动态的渲染组件. `Route`组件则是用来配置路径与组件之间的关系. 当匹配成功之后, 加载相对应的组件. 下面我们就来配置应用的路由.</div><div class="line"></div><div class="line">`Router`组件作为一个路由的容器组件, 可以在其内部通过 `Route` 配置多个映射关系. 但这里需要注意的是, 在`Router`组件中,只能出现一个子元素. 当有多个子元素时, 我们会使用一个元素给包裹起来.</div></pre></td></tr></table></figure>
<p>const myRouter = (<br>    <router><br>        <div><br>          // 多个子组件时, 要使用一个元素将其包裹起来<br>        </div><br>    </router><br>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们可以在 `Route` 组件上使用`path`属性表示可匹配的有效`url`, 然后使用`component`属性表示该`url`所对应的组件. 那这里, 我们首先添加 `login`, `reg` 和 `info` 的映射关系. </div><div class="line"></div><div class="line">分别引入这3个组件, 然后在`Router`组件中对根路径, `/reg`和`/info`进行配置.</div></pre></td></tr></table></figure></p>
<p>// app.js<br>import Login from “./components/login.js”<br>import Reg from “./components/reg.js”<br>import Info from “./components/info/info.js”</p>
<p>// 添加映射关系<br>const myRouter = (<br>    <router><br>        <div><br>           <route path="/" component="{" login="" }=""></route><br>           <route path="/reg" component="{" reg="" }=""></route><br>           <route path="/info" component="{" info="" }=""></route><br>        </div><br>    </router><br>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">配置完成之后, 可以看到浏览器已经成功加载登录页面. 同时, 地址栏也已经变成hash值的格式. </div><div class="line">这时, 修改`hash`值, 观察页面的变化.</div></pre></td></tr></table></figure></p>
<p>/ –&gt; /reg<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 3. Route 的 exact 属性</div><div class="line"></div><div class="line">我们将`url`从根路径修改成`/reg`, 这时, 在index.html页面中同时显示了登录和注册页面. 我们再将`/reg`修改成`/info`, 页面又显示了登录和信息管理. 那这里为什么一个url会显示2个视图呢?原因是: `route`在做路径匹配时, 会将当前的路径与配置所有路径一一匹配, 如果包含的话就会认为匹配成功. 因此, 当我们访问`/reg`或`/info`时, 根路径总会匹配成功. 如果要避免这种情况, 我们可以在`Route`上配置`exact`属性,来实现精确匹配.</div></pre></td></tr></table></figure></p>
<p><route exact="" path="/" component="{" login="" }=""></route><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这时, 页面就可以在`login`, `reg`和`info`之间相互切换了.</div><div class="line"></div><div class="line">我们除了可以通过修改`url`的值来切换视图以外, 还可以通过事件来触发视图的切换. 接下来, 在`Login`组件中, 给登录按钮和注册按钮添加点击事件, 点击之后分别跳转到相对应的页面.</div></pre></td></tr></table></figure></p>
<p>// login.js</p>
<p>login() {<br>    const {<br>        history<br>    } = this.props<br>    history.push(“/info”)<br>}</p>
<p>reg() {<br>    const {<br>        history<br>    } = this.props<br>    history.push(<code>/reg</code>)<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">定义 `login` 函数. 只要配置过映射关系的这些组件, 我们都可以在组件中通过`props`属性获取`Route`传递进来的参数. 在这些参数中, `history`对象就可以用来实现跳转. 他有一个`push`方法, 接收一个`url`作为参数, 当方法调用时, 页面就会跳转到指定的`url`. 这里, 当用户点击登录按钮时, 我们让视图切换到`/info`的路径, 也就是信息管理页面. 同理, 当用户点击注册按钮时, 切换到注册页面. 完成后, 点击登录注册按钮, 页面可以切换到相对应的视图.</div><div class="line"></div><div class="line">#### 4. Route 配置动态参数</div><div class="line"></div><div class="line">有时候, 还有这样的一些应用: 我们需要在一些页面中获取某个值, 然后将这个值传递到另一个页面中展示出来. 通常情况下, 我们可以使用`url`来记录需要传递的这些数据. `react-router`也为我们提供了一种配置方式, 来获取这些动态产生的数据.</div><div class="line"></div><div class="line">我们新增一个路由配置.</div></pre></td></tr></table></figure>
<p><route path="/login/:username" component="{" login="" }=""></route><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">注意, 在配置`path`属性时, `/login/`路径后面多了一个`:username`. 这种路径的表现方式, 意味这用户在访问`/login`时, 可以在这个路径后携带上一个参数, 然后在这个路径对应的组件中, 我们就可以使用冒号后面的标识符来获取携带的参数值.</div><div class="line"></div><div class="line">这里, 我们让用户在注册页面输入账户信息, 然后点击登录按钮, 跳转到登录页面, 同时, 系统将用户输入的账户名在登录的账户输入框中显示出来. </div><div class="line"></div><div class="line">- 首先在注册页面中, 点击登录按钮时, 获取用户输入的账户名, 我们可以使用`refs`属性来获取输入框的值.</div><div class="line">- 拿到用户输入的值之后, 接下来调用`history.push()`方法完成页面的跳转. 这时, 需要跳转的路径我们就可以这样来设置:</div></pre></td></tr></table></figure></p>
<pre><code>history.push(`/login/${this.refs.username.value}`)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我们可以将用户输入的值拼接在`/login/`路径后面.点击登录按钮之后,`url`变成`/login`加上用户输入的字符串.</div></pre></td></tr></table></figure>

http://localhost:8080/#/login/zhangsan
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">- 下一步我们来获取这个参数. 在`Login`组件中, 我们可以使用路由传递的`match`对象来获取这个参数值. 展开这个对象, 可以看到有一个`params`的属性, 其中`username`就是从`url`携带的参数值. 拿到这个参数后, 就可以直接渲染在页面上了.</div><div class="line"></div><div class="line">#### 5. Route render 方法和重定向 Redirect</div><div class="line"></div><div class="line">`Route`组件除了可以使用`component`属性来指定路径对应的组件以外, 还可以使用`render`属性来处理路径与组件的映射关系. `render`属性接受一个函数, 当路径匹配成功之后, 该函数被调用. 同时, `Route`组件会把本身传递给组件的这些参数传递给这个函数.</div><div class="line"></div><div class="line">这里我们假设, `isLogin`变量用来标志用户的登录状态, `true`表示已登录, `false`表示未登录, 默认值为 `false`. 我们只允许用户在登录状态下访问`/info`以及`/info`下的子页面. 这时, 就可以在`render`方法中对登录状态进行判断. </div><div class="line"></div><div class="line">当`isLogin`状态为`true`时, 我们直接返回`info`组件, 同时, 将`props`参数传递进去. 当状态为`false`时, 将路径导航到登录页面. `react-router`提供了一个`Redirect`组件专门用来实现路径的重定向, 我们只需要配置其`to`的属性, 指定新的地址就可以完成重定向. 这里, 我们重定向到根路径.</div></pre></td></tr></table></figure>
</code></pre><p>// 登录状态<br>let isLogin = false;</p>
<p><route path="/info" render="{(props)" ==""> {<br>    return isLogin ? <info {...props}=""> : <redirect to="/"><br>}}&gt;</redirect></info></route><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 当前`isLogin`状态为`false`, 意味着用户没有登录, 当点击登录按钮时, 页面不会跳转到`info`界面.</div><div class="line">- 修改`isLogin`为`true`, 再次点击登录按钮, 可以看到, 页面成功跳转的`info`界面.</div><div class="line"></div><div class="line">这里提醒大家的是, 当`Route`组件上, `render`属性和`component`属性同时存在时, `component`的优先级要高于`render`.`render`方法会无效.</div><div class="line"></div><div class="line">#### 6. Link 和 NavLink 声明式导航</div><div class="line"></div><div class="line">接下来, 我们再来看看, 在`info`页面中嵌套路由的用法.</div><div class="line"></div><div class="line">在`info`中包含4个子页面, 分别为学生信息, 教师信息, 员工信息和系统信息. 首先引入这些组件. 这里, 我们通过导航栏的形式,来显示这些页面. 整个`info`页面分成左右两个部分, 左侧为页面导航部分, 当前`url`所对应的视图在右侧显示. 咱们首先来添加导航栏. </div><div class="line">`react-router`提供了一个`Link`组件来实现这种声明式导航. 我们只需要在`li`元素中使用这个组件即可. 该组件通过`to属性`来配置需要导航的路径.</div></pre></td></tr></table></figure></p>
<p><ul><br>    <li><link to="{`/info/teacher`}">教师管理</li><br>    <li><link to="{`/info/emp`}">员工管理</li><br>    <li><link to="{`/info/student`}">学生管理</li><br>    <li><link to="{`/info/system`}">系统管理</li><br></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">导航栏配置完成. 接下来, 我们在右侧区域, 使用`Route`组件配置路径和组件的映射关系.</div></pre></td></tr></table></figure></p>
<p><route path="{`/info/teacher`}" component="{Teacher}"></route></p>
<p><route path="{`/info/emp`}" component="{Emp}"></route></p>
<p><route path="{`/info/student`}" component="{Student}"></route></p>
<p><route path="{`/info/system`}" component="{System}"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用方法和刚刚的配置方法一样, `path`属性用来指定路径, `component`属性用来指定该路径映射的组件. </div><div class="line">配置完成之后, 我们就可以通过导航栏来切换视图了.</div><div class="line"></div><div class="line">除了`Link`组件以外, `react-router`还提供了一个`NavLink`用来实现导航, 使用这个组件, 当url匹配成功之后, 它会给导航按钮添加指定的样式.</div><div class="line"></div><div class="line">我们将`Link`替换成`NavLink`, 这个组件通过`activeClassName`或`activeStyle`属性来为激活状态下的按钮添加样式. 这里我们使用`activeStyle`属性, 设置激活状态下导航按钮的字体颜色为红色.</div></pre></td></tr></table></figure></route></p>
<p><ul><br>    <li><link to="{`/info/teacher`}">教师管理</li><br>    <li><link to="{`/info/emp`}">员工管理</li><br>    <li><link to="{`/info/student`}">学生管理</li><br>    <li><link to="{`/info/system`}">系统管理</li><br></ul><br>```</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tangzhenh.com/2017/06/02/react-router-v4-x/" data-id="cj3flegdk00015fnra1d5bj6k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/06/02/symbol/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">symbol</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/02/react-router-v4-x/">react-router_v4.x</a>
          </li>
        
          <li>
            <a href="/2017/06/02/symbol/">symbol</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 tangzhenh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>